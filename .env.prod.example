# =============================================================================
# .env.prod.example – Production environment for docker-compose.prod.yml
#
# IMPORTANT: This file serves as a template. Copy it to .env.prod and fill in
# all required values before deploying.
#
# Generate secrets with:
#   openssl rand -hex 32
#
# Architecture:
#   - Nginx reverse proxy on port 80 (only exposed port)
#   - Medusa server (server mode) - handles API and Admin
#   - Medusa worker (worker mode) - processes background jobs
#   - Next.js storefront
#   - PostgreSQL database (internal)
#   - Redis (internal)
# =============================================================================

# --- PostgreSQL ---------------------------------------------------------------
POSTGRES_DB=medusa-store
POSTGRES_USER=postgres
# REQUIRED – Use a strong password (minimum 32 characters recommended)
POSTGRES_PASSWORD=

# Full connection URL consumed by Medusa (must match POSTGRES_USER/POSTGRES_PASSWORD above)
DATABASE_URL=postgres://postgres:YOUR_POSTGRES_PASSWORD@postgres:5432/medusa-store

# --- Redis --------------------------------------------------------------------
# Redis is used for: caching, event bus, workflow engine, locking, and sessions
REDIS_URL=redis://redis:6379
# Optional: separate Redis URLs for cache/locking (defaults to REDIS_URL if unset)
CACHE_REDIS_URL=redis://redis:6379
LOCKING_REDIS_URL=redis://redis:6379

# --- Medusa Secrets -----------------------------------------------------------
# REQUIRED – Generate with: openssl rand -hex 32
# NEVER commit these to version control
JWT_SECRET=
COOKIE_SECRET=

# --- Worker Mode Configuration ------------------------------------------------
# Set to "server" for the API/Admin instance
# Set to "worker" for the background job processor instance
# This is configured in docker-compose.prod.yml per service
MEDUSA_WORKER_MODE=server

# --- Admin Configuration ------------------------------------------------------
# Disable admin in worker mode only
DISABLE_MEDUSA_ADMIN=false

# --- CORS Configuration -------------------------------------------------------
# Set to the public URLs where the storefront and admin are accessible
# Use your actual domain names in production (e.g., https://yourdomain.com)
# When using nginx, these should point to the nginx URLs
STORE_CORS=http://localhost
ADMIN_CORS=http://localhost
# Comma-separated list of URLs that can authenticate
AUTH_CORS=http://localhost

# --- Backend Configuration ----------------------------------------------------
# Public URL of the Medusa backend (where Admin will send requests)
MEDUSA_BACKEND_URL=http://localhost

# Public URL of the storefront (for Admin links to storefront pages)
MEDUSA_STOREFRONT_URL=http://localhost

# --- Storefront Configuration -------------------------------------------------
# Public URL of the Medusa backend reachable from the browser
# When using nginx, this should be the nginx URL
NEXT_PUBLIC_MEDUSA_BACKEND_URL=http://localhost

# Publishable API key – obtain from the Medusa Admin after first boot:
#   1. Start the application: docker compose -f docker-compose.prod.yml --env-file .env.prod up -d
#   2. Access Admin: http://localhost/app
#   3. Navigate to: Settings → Publishable API Keys
#   4. Create a new key or copy an existing one
#   5. Update this value and rebuild storefront: docker compose -f docker-compose.prod.yml --env-file .env.prod up --build storefront -d
NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY=

# B2C / B2B channel publishable keys (run: docker compose exec medusa yarn seed:silk to generate)
# After seed, find keys in seed output or Admin → Settings → Publishable API Keys
NEXT_PUBLIC_MEDUSA_B2C_PUBLISHABLE_KEY=
NEXT_PUBLIC_MEDUSA_B2B_PUBLISHABLE_KEY=

# Public URL of the storefront itself
NEXT_PUBLIC_BASE_URL=http://localhost

# Default region for the storefront
NEXT_PUBLIC_DEFAULT_REGION=us

# Next.js on-demand revalidation secret – Generate with: openssl rand -hex 32
# REQUIRED for ISR (Incremental Static Regeneration) to work
REVALIDATE_SECRET=

# --- Stripe Payment Provider --------------------------------------------------
# Required for card payments. Obtain from https://dashboard.stripe.com/apikeys
# Leave empty to disable Stripe (backend will fall back to manual payment only)
STRIPE_API_KEY=
STRIPE_WEBHOOK_SECRET=
# Public key used in the storefront checkout
NEXT_PUBLIC_STRIPE_KEY=

# --- S3 File Provider (product images & uploads) ------------------------------
# Leave empty to use the local file module (development only)
# Supports: AWS S3, MinIO, DigitalOcean Spaces, Cloudflare R2, Supabase Storage
S3_FILE_URL=
S3_ACCESS_KEY_ID=
S3_SECRET_ACCESS_KEY=
S3_REGION=
S3_BUCKET=
# S3_ENDPOINT=   # Only needed for non-AWS providers (MinIO, DO Spaces, R2, etc.)

# --- SMTP / Nodemailer (transactional emails) ----------------------------------
# Leave empty to disable email notifications
# Works with any SMTP: Gmail, Mailgun, SES, self-hosted Postfix, etc.
SMTP_HOST=
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
SMTP_FROM=noreply@example.com
# Set to "true" for port 465 (SMTPS), "false" for STARTTLS (port 587)
SMTP_SECURE=false

# =============================================================================
# PRODUCTION DEPLOYMENT CHECKLIST
# =============================================================================
#
# Security:
#   ✓ All secrets (JWT_SECRET, COOKIE_SECRET, POSTGRES_PASSWORD, REVALIDATE_SECRET) are randomly generated
#   ✓ .env.prod is in .gitignore and NEVER committed to version control
#   ✓ PostgreSQL and Redis are NOT exposed to 0.0.0.0 (only internal network)
#   ✓ Only nginx listens on port 80 (external)
#   ✓ CORS is configured with actual domain names (not *)
#
# Performance:
#   ✓ Redis is configured for caching, event bus, workflow engine, and locking
#   ✓ Worker mode is enabled (separate server and worker instances)
#   ✓ Nginx has gzip compression enabled
#   ✓ Rate limiting is configured in nginx
#
# High Availability (Optional):
#   □ Use managed PostgreSQL (AWS RDS, Google Cloud SQL, etc.)
#   □ Use managed Redis (AWS ElastiCache, Redis Cloud, etc.)
#   □ Set up SSL/TLS certificates (Let's Encrypt with certbot)
#   □ Configure health checks for all services
#   □ Set up monitoring and logging (e.g., Datadog, New Relic)
#   □ Configure backup strategy for PostgreSQL
#
# =============================================================================
