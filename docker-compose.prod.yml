# Production Docker Compose for Medusa B2B Starter
# WITH NGINX REVERSE PROXY
#
# Architecture:
#   - Nginx: Reverse proxy handling all external traffic (port 80)
#   - Medusa Server: Handles API requests and Admin (server mode)
#   - Medusa Worker: Processes background jobs (worker mode)
#   - Storefront: Next.js application
#   - PostgreSQL: Database (internal only)
#   - Redis: Cache/sessions/workflow engine (internal only)
#
# Usage:
#   1. Copy .env.prod.example to .env.prod and fill in all values
#   2. Run migrations:
#        docker compose -f docker-compose.prod.yml --env-file .env.prod \
#          run --rm medusa-migrate
#   3. Start all services:
#        docker compose -f docker-compose.prod.yml --env-file .env.prod up -d
#   4. Access the application:
#        - Storefront: http://localhost
#        - Admin: http://localhost/app
#        - API: http://localhost/api

services:

  # ---------------------------------------------------------------------------
  # NGINX - Reverse Proxy (Entrypoint for all traffic)
  # ---------------------------------------------------------------------------
  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile
    container_name: medusa_nginx_prod
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      medusa:
        condition: service_healthy
      storefront:
        condition: service_started
    environment:
      DOMAIN: ${DOMAIN:?DOMAIN is required — set it in .env.prod}
    volumes:
      - letsencrypt_data:/etc/letsencrypt
      - certbot_webroot:/var/www/certbot
    networks:
      - medusa_network
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 15s

  # ---------------------------------------------------------------------------
  # PostgreSQL - Database (internal only)
  # ---------------------------------------------------------------------------
  postgres:
    image: postgres:15-alpine
    container_name: medusa_postgres_prod
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-medusa-store}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - medusa_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
    # Security: Do NOT expose PostgreSQL ports to host in production

  # ---------------------------------------------------------------------------
  # Redis - Cache/Sessions/Workflow Engine (internal only)
  # ---------------------------------------------------------------------------
  redis:
    image: redis:7-alpine
    container_name: medusa_redis_prod
    restart: unless-stopped
    # noeviction is required by Medusa's workflow engine (BullMQ)
    command: redis-server --maxmemory 512mb --maxmemory-policy noeviction
    volumes:
      - redis_data:/data
    networks:
      - medusa_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    # Security: Do NOT expose Redis ports to host in production

  # ---------------------------------------------------------------------------
  # Migration Service (one-off)
  # Run manually before deployment:
  #   docker compose -f docker-compose.prod.yml --env-file .env.prod \
  #     run --rm medusa-migrate
  # ---------------------------------------------------------------------------
  medusa-migrate:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
    image: medusa-backend-prod
    container_name: medusa_migrate
    restart: "no"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      NODE_ENV: production
      DATABASE_URL: ${DATABASE_URL:?DATABASE_URL is required}
      REDIS_URL: ${REDIS_URL:?REDIS_URL is required}
      JWT_SECRET: ${JWT_SECRET:?JWT_SECRET is required}
      COOKIE_SECRET: ${COOKIE_SECRET:?COOKIE_SECRET is required}
      STORE_CORS: https://${DOMAIN}
      ADMIN_CORS: https://${DOMAIN}
      AUTH_CORS: https://${DOMAIN}
      MEDUSA_WORKER_MODE: shared
      DISABLE_MEDUSA_ADMIN: "true"
    command: ["yarn", "medusa", "db:migrate"]
    networks:
      - medusa_network

  # ---------------------------------------------------------------------------
  # Medusa Server (SERVER MODE ONLY)
  # Handles API requests and serves Admin dashboard
  # ---------------------------------------------------------------------------
  medusa:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
      args:
        MEDUSA_BACKEND_URL: https://${DOMAIN}
    image: medusa-backend-prod
    container_name: medusa_server_prod
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      NODE_ENV: production
      MEDUSA_WORKER_MODE: server
      DISABLE_MEDUSA_ADMIN: "false"
      DATABASE_URL: ${DATABASE_URL:?DATABASE_URL is required}
      REDIS_URL: ${REDIS_URL:?REDIS_URL is required}
      JWT_SECRET: ${JWT_SECRET:?JWT_SECRET is required}
      COOKIE_SECRET: ${COOKIE_SECRET:?COOKIE_SECRET is required}
      STORE_CORS: https://${DOMAIN}
      ADMIN_CORS: https://${DOMAIN}
      AUTH_CORS: https://${DOMAIN}
      MEDUSA_BACKEND_URL: https://${DOMAIN}
      MEDUSA_STOREFRONT_URL: https://${DOMAIN}
      PORT: 9000
    networks:
      - medusa_network
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:9000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    # Do NOT expose port 9000 to host - nginx handles all external traffic

  # ---------------------------------------------------------------------------
  # Medusa Worker (WORKER MODE ONLY)
  # Processes background jobs, workflows, scheduled jobs, subscribers
  # ---------------------------------------------------------------------------
  medusa-worker:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
    image: medusa-backend-prod
    container_name: medusa_worker_prod
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      medusa:
        condition: service_healthy
    environment:
      NODE_ENV: production
      MEDUSA_WORKER_MODE: worker
      DISABLE_MEDUSA_ADMIN: "true"
      DATABASE_URL: ${DATABASE_URL:?DATABASE_URL is required}
      REDIS_URL: ${REDIS_URL:?REDIS_URL is required}
      JWT_SECRET: ${JWT_SECRET:?JWT_SECRET is required}
      COOKIE_SECRET: ${COOKIE_SECRET:?COOKIE_SECRET is required}
      STORE_CORS: https://${DOMAIN}
      ADMIN_CORS: https://${DOMAIN}
      AUTH_CORS: https://${DOMAIN}
    networks:
      - medusa_network
    # Worker has no health check - it doesn't expose HTTP endpoints

  # ---------------------------------------------------------------------------
  # Storefront (Next.js)
  # NEXT_PUBLIC_* variables are baked into the build
  # Rebuild the image if these values change
  # ---------------------------------------------------------------------------
  storefront:
    build:
      context: ./storefront
      dockerfile: Dockerfile.prod
      args:
        NEXT_PUBLIC_MEDUSA_BACKEND_URL: https://${DOMAIN}
        NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY: ${NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY:?NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY is required}
        NEXT_PUBLIC_BASE_URL: https://${DOMAIN}
        NEXT_PUBLIC_DEFAULT_REGION: ${NEXT_PUBLIC_DEFAULT_REGION:-us}
    container_name: medusa_storefront_prod
    restart: unless-stopped
    depends_on:
      medusa:
        condition: service_healthy
    environment:
      NODE_ENV: production
      REVALIDATE_SECRET: ${REVALIDATE_SECRET:?REVALIDATE_SECRET is required}
      PORT: 3000
      # Server-side only: storefront SSR/middleware reaches Medusa directly via Docker network
      # This is NOT baked into client JS - browser still uses NEXT_PUBLIC_MEDUSA_BACKEND_URL
      MEDUSA_BACKEND_URL: http://medusa:9000
    networks:
      - medusa_network
    # Do NOT expose port 3000 to host - nginx handles all external traffic

  # ---------------------------------------------------------------------------
  # Certbot — TLS certificate issuance and auto-renewal (Let's Encrypt)
  # Run once manually: bash scripts/init-ssl.sh
  # Auto-renewal: runs every 12 h inside this container
  # ---------------------------------------------------------------------------
  certbot:
    image: certbot/certbot
    container_name: medusa_certbot_prod
    restart: unless-stopped
    volumes:
      - letsencrypt_data:/etc/letsencrypt
      - certbot_webroot:/var/www/certbot
    # Attempt renewal every 12 h; certbot skips if cert is still valid
    entrypoint: /bin/sh -c 'trap exit TERM; while :; do certbot renew --quiet; sleep 12h & wait $${!}; done'
    depends_on:
      - nginx
    networks:
      - medusa_network

# ---------------------------------------------------------------------------
# Named volumes - Data persisted across container restarts
# ---------------------------------------------------------------------------
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  letsencrypt_data:
    driver: local
  certbot_webroot:
    driver: local

# ---------------------------------------------------------------------------
# Internal bridge network - Services communicate by service name
# Security: No ports exposed to 0.0.0.0, only nginx listens on port 80
# ---------------------------------------------------------------------------
networks:
  medusa_network:
    driver: bridge
